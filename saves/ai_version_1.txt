extends KinematicBody2D

# Speed constants
var acc_const = 0.3;
var drag_const = 0.99;
var brake_const = 0.95;

# Velocities, Throttles and Steers
var max_velocity = 20;
var min_velocity = -5;
var velocity = 0;
var accel = 0;
var steer = 0;

# Sensors
var right = 0;
var left = 0;

# Network
var weights = [];
var biases = [];

func sigmoid(x):
	return 1/(1 + exp(-x));

# Calculation
var ms;

func calculate(R, L):
	ms = [0, 0, 0];
	
	# Get R and L ws and bs
	var w1 = weights[0];
	var b1 = biases[0];
	
	var w2 = weights[0];
	var b2 = biases[0];
	
	# Compute mid ms
	
	ms[0] = log(abs((w1[0] * R + b1[0]) + (w2[0] * L + b2[0])));
	ms[1] = log(abs((w1[1] * R + b1[1]) + (w2[1] * L + b2[1])));
	ms[2] = log(abs((w1[2] * R + b1[2]) + (w2[2] * L + b2[2])));
	
	# Get mid ws and bs
	
	var outs = [0, 0, 0];
	
	var wm1 = weights[2];
	var bm1 = biases[2];
	
	var wm2 = weights[3];
	var bm2 = biases[3];
	
	var wm3 = weights[4];
	var bm3 = biases[4];
	
	# Compute outs
	
	outs[0] = (wm1[0] * ms[0] + bm1[0]) + \
		(wm2[0] * ms[1] + bm2[0]) + \
		(wm3[0] * ms[2] + bm3[0]);
	outs[1] = (wm1[1] * ms[0] + bm1[1]) + \
		(wm2[1] * ms[1] + bm2[1]) + \
		(wm3[1] * ms[2] + bm3[1]);
	outs[2] = (wm1[2] * ms[0] + bm1[2]) + \
		(wm2[2] * ms[1] + bm2[2]) + \
		(wm3[2] * ms[2] + bm3[2]);
	
	for i in range(0, 3):
		outs[i] /= 10;
	
	outs[0] = 100 * sigmoid(outs[0]);
	outs[1] = tanh(outs[1]);
	outs[2] = tanh(outs[2]);
	
	# print(outs);
	
	return outs;

# Conjugation
func conjugate(outs):
	return [100 - outs[0], -outs[1], -outs[2]];

# Learning
var gamma = 0.861;

func autodiff(state, err, gm):
	for i in range(0, 2):
		for j in range(0, 3):
			for k in range(0, 3):
				weights[i][j] -= gm * err[k] * weights[j][k] * \
					(state[i]/(state[i] * weights[i][j] + biases[i][j]));
				biases[i][j] -= gm * err[k] * weights[j][k] / \
					(state[i] * weights[i][j] + biases[i][j]);
	
	for i in range(2, 5):
		for j in range(0, 3):
			biases[i][j] -= gm * err[j];
			weights[i][j] -= gm * err[j] * ms[i - 2];
	
	pass;

func learn():
	var top = buff.size() - 1;
	
	print("Learning...");
	
	for i in range(top, -1, -1):
		calculate(states[i][0], states[i][1]);
		
		var conj = conjugate(buff[i]);
		
		var tmp = [];
		for j in range(0, 3):
			tmp.append((conj[j] - buff[i][j])/(abs(conj[j]) + 0.01));
		
		autodiff(states[i], tmp, pow(gamma, top - i));
		

# Buffers, Distances
var buff = [];
var dists = [];
var states = [];

var index = -1;

var buff_size = 180;

# Rngs
var rng = RandomNumberGenerator.new();

# Setp
func _ready():
	get_node("Camera2D").current = true;
	
	rng.randomize();
	
	for i in range(0, 5):
		var ws = []
		var bs = []
		
		for i in range(0, 3):
			ws.append(rng.randf_range(-10, 10));
			bs.append(rng.randf_range(-10, 10));
		
		weights.append(ws);
		biases.append(bs);
	
	print("weights: " + String(weights));
	print("biases: " + String(biases));
	
	pass

# Process (Run)
func _process(delta):
	var vecs = calculate(right, left);
	
	if buff.size() > buff_size:
		buff.remove(0);
	
	buff.append(vecs);
	
	if states.size() > buff_size:
		states.remove(0);
	
	states.append([right, left]);
	
	# Braking and Acceleration
	# var acceleration = rng.randf_range(0, 1) * acc_const;
	
	# var brake = rng.randi_range(0, 2);
	
	if vecs[1] > 1/3:
		accel = 0;
		velocity *= brake_const;
	elif vecs[1] < -1/3:
		accel = vecs[0] * acc_const;
		velocity += vecs[0] * acc_const;
	else:
		accel = 0;
		velocity *= drag_const;
	
	velocity = min(velocity, max_velocity);
	velocity = max(velocity, min_velocity);
	
	var col = move_and_collide(Vector2(cos(rotation),
		sin(rotation)) * velocity);
	
	# Steering
	# var steer = rng.randi_range(-1, 1);
	
	rotation += velocity * vecs[2] * 0.0025;
	
	steer = vecs[2];
	
	""" if vecs[2] > 1/3:
		rotation += velocity * 0.0025;
	elif vecs[2] < -1/3:
		rotation -= velocity * 0.0025; """
	
	if index == -1:
		dists.append(delta * velocity);
	else:
		dists.append(delta * velocity + dists[index]);
	
	if dists.size() > buff_size:
		if dists[buff_size] < 10:
			col = self;
		
		dists.remove(0);
	else:
		index += 1;
		
	if col:
		reset();

# Reset
func reset():
	velocity = 0;
	
	position = get_parent().get_node("spawn").position;
	
	rotation = 0;
	
	learn();
	
	print("------------------------------------------------");
	print("weights: " + str(weights));
	print("biases: " + str(biases));
	
	buff.clear();
	
	dists.clear();
	index = -1;
	
	pass;

