extends KinematicBody2D

export (Array, NodePath) var spath;

# Speed constants
var acc_const = 0.3;
var drag_const = 0.99;
var brake_const = 0.95;

# Velocities, Throttles, Steers and Brakes
var max_velocity = 20;
var min_velocity = -5;
var velocity = 0;
var accel = 0;
var steer = 0;
var brakes = 0;
var score = 0;

# Sensors
var right = 0;
var left = 0;
var front = 0;
var back = 0;
var fright = 0;
var fleft = 0;
var bright = 0;
var bleft = 0;

# Time Control
var dlt = 0;
var time = 0;

# Buffers, Distances
var buff = [];
var dists = [];
var states = [];
var dist = 0;
var Rt = 0;
var sig = 0;

var index = -1;

var buff_size = 180;

var parent = null;

# Linalg Computation and Network

# Return a dot b
func dot(a, b):
	var tmp = 0;
	
	# Speed up to log(n) addition if needed
	for i in range(0, a.size()):
		tmp += a[i] * b[i];
	
	return tmp;

func m_sclr(A, x):
	var out = [];
	
	for i in A:
		var row = [];
		
		for j in i:
			row.append(x * j);
		
		out.append(row);
	
	return out;

func v_sclr(A, x):
	var out = [];
	
	for i in A:
		out.append(x * i);
	
	return out;

func transpose(M):
	var size = M[0].size();
	
	var Mt = [];
	
	for i in range(0, size):
		var row = [];
		
		for j in range(0, M.size()):
			row.append(M[j][i]);
		
		Mt.append(row);
	
	return Mt;

func vtom(M):
	var out = [];
	
	for i in M:
		out.append([i]);
	
	return out;

func mtov(M):
	var out = [];
	
	for i in M:
		out.append(i[0]);
	
	return out;

func mult(A, B):
	var out = [];
	
	assert(A[0].size() == B.size());
	
	var sx = A.size();
	var sy = B[0].size();
	var ms = B.size();
	
	for i in range(0, sx):
		var row = []
		for j in range(0, sy):
			var t = 0;
			
			for k in range(0, ms):
				t += A[i][k] * B[k][j];
		
			row.append(t);
		
		out.append(row);
	
	return out;

func m_add(A, B):
	assert(A.size() == B.size()
		and A[0].size() == B[0].size());
	
	var sx = A.size();
	var sy = A[0].size();
	
	var out = [];
	
	for i in range(0, sx):
		var row = [];
		
		for j in range(0, sy):
			row.append(A[i][j] + B[i][j]);
		
		out.append(row);
	
	return out;

func v_add(A, B):
	assert(A.size() == B.size());
	
	var sz = A.size();
	
	var out = [];
	
	for i in range(0, sz):
		out.append(A[i] + B[i]);
	
	return out;

func shur(A, B):
	assert(A.size() == B.size()
		and A[0].size() == B[0].size());
	
	var sx = A.size();
	var sy = A[0].size();
	
	var out = [];
	
	for i in range(0, sx):
		var row = [];
		
		for j in range(0, sy):
			row.append(A[i][j] * B[i][j]);
		
		out.append(row);
	
	return out;

# Returns tanh(MI + B)
func fma(M, I, B):
	var out = [];
	
	for k in range(0, M.size()):
		out.append(dot(M[k], I) + B[k]);
	
	return out;

func vtanh(A):
	var O = [];
	
	for i in A:
		O.append(tanh(i));
	
	return O;

# Derivative of activation
func dtanh(x):
	var t = cosh(x);
	
	return 1/(t * t);

func vdtanh(A):
	var O = [];
	
	for i in A:
		O.append([dtanh(i)]);
	
	return O;

# Computation of values
var M0 = [];
var M1 = [];
var M2 = [];
var O = [];

var Z1 = [];
var Z2 = [];
var Z3 = [];

func calculate(X):
	# State Saving
	M0 = X;
	
	Z1 = fma(parent.W1, M0, parent.B1);
	M1 = vtanh(Z1);
	
	Z2 = fma(parent.W2, M1, parent.B2);
	M2 = vtanh(Z2);
	
	Z3 = fma(parent.W3, M2, parent.B3);
	O = vtanh(Z3);
	
#	print("\nX: " + str(X) + "\n");
	
	return O;

# Cost

func cost(R):
	var tb;
	var ts;
	
	if R > 0:
		tb = O[0] + 0.9;
	else:
		if O[0] > 0:
			tb = -1;
		else:
			tb = 0.3;
	
	if sig:
		tb = 0;
		
		if M0[4] < M0[5]:
			ts = O[1] - 1;
		else:
			ts = O[0] + 1;
		
#		if abs(O[1]) > 0.5:
#			if O[1] > 0:
#				ts = 1;
#			else:
#				ts = -1;
#		else:
#			if O[1] > 0:
#				ts = 0.05;
#			else:
#				ts = -0.05;
#
#			if O[0] < 0:
#				tb = 1;
	else:
		ts = 0;
	
	return [[tb], [ts]];

# Gradient
var dW1 = [];
var dW2 = [];
var dW3 = [];

var dB1 = [];
var dB2 = [];
var dB3 = [];

func gradient(R):
#	print("\n(Z1): " + str(Z1));
#	print("(Z2): " + str(Z2));
#	print("(Z3): " + str(Z3));

	var m = cost(R);
	
	var dZ1 = vdtanh(Z1);
	var dZ2 = vdtanh(Z2);
	var dZ3 = vdtanh(Z3);

#	print("\ntanh'(Z1): " + str(dZ1));
#	print("tanh'(Z2): " + str(dZ2));
#	print("tanh'(Z3): " + str(dZ3) + "\n");
	
	dB3 = shur(dZ3, m);
#	dB3 = dZ3;
	dB2 = shur(mult(transpose(parent.W3), dB3), dZ2);
	dB1 = shur(mult(transpose(parent.W2), dB2), dZ1);
	
	dW3 = mult(dB3, transpose(vtom(M2)));
	dW2 = mult(dB2, transpose(vtom(M1)));
	dW1 = mult(dB1, transpose(vtom(M0)));

var alpha = 0.03;

func learn(R):
#	print("================================");
	
	gradient(R);
	
	R = abs(R);
	
	# print("Scale: " + str(alpha * R));
	
#	print("\nPRE-SCALE:");
#	print("dW1 : " + str(dW1));
#	print("dW2 : " + str(dW2));
#	print("dW3 : " + str(dW3) + "\n");
#
#	print("dB1 : " + str(dB1));
#	print("dB2 : " + str(dB2));
#	print("dB3 : " + str(dB3) + "\n");
	
	dW1 = m_sclr(dW1, alpha * R);
	dW2 = m_sclr(dW2, alpha * R);
	dW3 = m_sclr(dW3, alpha * R);
	
	dB1 = v_sclr(mtov(dB1), alpha * R);
	dB2 = v_sclr(mtov(dB2), alpha * R);
	dB3 = v_sclr(mtov(dB3), alpha * R);
#
#	print("\nPOST-SCALE:")
#	print("dW1 : " + str(dW1));
#	print("dW2 : " + str(dW2));
#	print("dW3 : " + str(dW3) + "\n");
#
#	print("dB1 : " + str(dB1));
#	print("dB2 : " + str(dB2));
#	print("dB3 : " + str(dB3) + "\n");
	
	parent.W1 = m_add(parent.W1, dW1);
	parent.W2 = m_add(parent.W2, dW2);
	parent.W3 = m_add(parent.W3, dW3);
	
	parent.B1 = v_add(parent.B1, dB1);
	parent.B2 = v_add(parent.B2, dB2);
	parent.B3 = v_add(parent.B3, dB3);
	
#	print("================================");

# Environment
func score(velocity, D, C):
	if C < 1:
		if velocity < 15:
			return -min(1/(velocity + 0.1), 0.1);
		
		return velocity/max_velocity;
	else:
		return -(velocity + 1);

# Setup (Ready)
var ppos = null;

func _ready():
	parent = get_parent();
	
	print([[1, 2], [3, 2], [1, 0]])
	print(transpose([[1, 2], [3, 2], [1, 0]]))
	
	ppos = position;

# Process (Run)
func _process(delta):
	time += delta;
	dlt = delta;
	
	# Buffer/History
	var vecs = calculate([right, left, front, back,
		fright, fleft, bright, bleft]);
	
	if buff.size() > buff_size:
		buff.remove(0);
	
	buff.append(vecs);
	
	if states.size() > buff_size:
		states.remove(0);
	
	states.append([right, left, front, back, fright, fleft, bright, bleft]);
	
	# Braking and Acceleration
	brakes = vecs[0];
	
	if vecs[0] > 0:
		accel = acc_const;
		
		velocity *= brake_const;
	else:
		accel = 0;
		
		velocity += acc_const;
	
	velocity = min(velocity, max_velocity);
	velocity = max(velocity, min_velocity);
	
	var col = move_and_collide(Vector2(cos(rotation),
		sin(rotation)) * velocity);
	
	# Steering
	steer = vecs[1];
	
	rotation += velocity * steer * 0.0025;
	
	# if steer > 0:
	# 	rotation += velocity * 0.0025;
	# else:
	# 	rotation -= velocity * 0.0025;
	
	if index == -1:
		dists.append((position - ppos).length());
		
		dist = dists[0];
	else:
		dists.append(delta * velocity + dists[index]);
		
		dist = (position - ppos).length() + dists[index]
	
	if dists.size() > buff_size:
		if (dists[buff_size] - dists[0]) < 1:
			reset();
			
			return;
		
		dists.remove(0);
	else:
		index += 1;
	
#	print(position - ppos);
	
	ppos = position;
	
	sig = 0;
	
	if col:
		sig = 1;
	
	Rt = score(velocity, dists[index], sig);
	
	learn(Rt);
	
	score += score(velocity, dists[index], sig);

# Reseting the Agent
func reset():
	position = get_node(spath[parent.rng \
		.randi_range(0, spath.size() - 1)]).position;
#
#	position = get_node(spath[0]).position;

	# Statistics Update
	parent.rounds += 1;
	
	# Reset Variables
	velocity = 0;
	rotation = 0;
	index = -1;
	time = 0;
	score = 0;
	
	ppos = position;
	
	dists.clear();
	buff.clear();
	
	pass;

